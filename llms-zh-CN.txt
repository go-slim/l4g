# l4g - Go 轻量级日志库

> 兼容 log/slog 的高性能结构化日志库

## 项目概述

l4g 是为 Go 应用程序设计的轻量级、高性能结构化日志库。它提供简单的、兼容 slog 的 API，在禁用的日志级别上实现零分配，并通过缓冲池最小化垃圾回收压力。

### 核心特性
- 禁用的日志级别零分配
- 完整的键值对结构化日志支持
- 兼容 Go 标准库 log/slog 包
- 7 个日志级别：Trace、Debug、Info、Warn、Error、Panic、Fatal
- 终端输出的可选 ANSI 颜色支持
- 命名通道支持组件特定的日志器
- 使用 sync.Map 和原子操作的线程安全设计
- 通过 sync.Pool 实现缓冲池
- 支持 Printf 风格和 JSON 风格的日志

### 设计理念
1. 性能优先：日志禁用时零分配
2. 简洁性：类似标准库的易用 API
3. 灵活性：可自定义的处理器和格式化器
4. 安全性：默认线程安全
5. 兼容性：兼容现有 slog 处理器

## 架构

### 核心组件

#### 1. Logger（日志器，logger.go）
用户交互的主要日志接口。

**关键类型：**
- `Logger`：带有级别、输出和处理器的主日志器实例
- `Options`：创建日志器的配置结构体

**关键方法：**
- `New(opts Options) *Logger`：使用选项创建新日志器
- `Log(level, msg, ...attrs)`：通用日志方法
- `Trace/Debug/Info/Warn/Error/Panic/Fatal(msg, ...attrs)`：级别特定方法
- `Tracef/Debugf/Infof/Warnf/Errorf/Panicf/Fatalf(format, ...args)`：Printf 风格
- `Tracej/Debugj/Infoj/Warnj/Errorj/Panicj/Fatalj(map)`：JSON 风格
- `WithAttrs(...attrs) *Logger`：创建带预设属性的派生日志器
- `WithPrefix(prefix) *Logger`：创建带前缀的派生日志器
- `WithGroup(name) *Logger`：创建带属性分组的派生日志器
- `SetLevel(Level)`：动态更改最小日志级别
- `SetOutput(io.Writer)`：动态更改输出目标
- `Enabled(Level) bool`：检查级别是否启用

**Options 字段：**
- `Prefix string`：所有日志消息的前缀
- `Level Level`：最小日志级别（默认：Info）
- `NewHandlerFunc func(HandlerOptions) Handler`：处理器工厂
- `Handler Handler`：自定义处理器（覆盖工厂）
- `ReplaceAttr func([]string, Attr) Attr`：属性转换函数
- `TimeFormat string`：时间格式（默认：time.StampMilli）
- `Output io.Writer`：输出目标（默认：os.Stderr）
- `NoColor bool`：禁用颜色（默认：false）

#### 2. Level（日志级别，level.go）
日志级别定义和管理。

**常量（iota + 1，值为 1-7）：**
- `LevelTrace = 1`：最详细，用于详细调试
- `LevelDebug = 2`：开发和调试信息
- `LevelInfo = 3`：一般信息消息（默认）
- `LevelWarn = 4`：潜在有害情况的警告消息
- `LevelError = 5`：错误条件
- `LevelPanic = 6`：严重错误，记录后调用 panic()
- `LevelFatal = 7`：关键错误，记录后调用 os.Exit(1)

**关键类型：**
- `Level int`：日志级别类型
- `LevelVar`：使用 atomic.Int32 的线程安全可变级别
- `Leveler interface`：具有 Level() 方法的类型接口

**关键方法：**
- `Level.String() string`：返回 "trace"、"debug"、"info" 等
- `Level.Int() int`：返回整数值（1-7）
- `Level.Real() Level`：将值限制在有效范围内
- `Level.MarshalJSON/UnmarshalJSON`：JSON 序列化
- `Level.MarshalText/UnmarshalText`：文本序列化
- `NewLevelVar(Level) *LevelVar`：创建线程安全的级别变量
- `LevelVar.Set(Level)`：原子更新级别
- `LevelVar.Level() Level`：原子读取级别

#### 3. Handler（处理器，handler.go）
输出格式化和处理。

**接口：**
- `Handler`：日志处理器的核心接口
  - `Enabled(Level) bool`：检查级别是否应该被记录
  - `Handle(Record) error`：处理和输出日志记录
  - `WithAttrs([]Attr) Handler`：创建带预设属性的处理器
  - `WithGroup(name) Handler`：创建带属性分组的处理器
  - `WithPrefix(prefix) Handler`：创建带前缀的处理器

**SimpleHandler 实现：**
- 快速、彩色的文本输出
- 包含时间、级别、前缀、消息和属性
- ANSI 颜色支持（8 位颜色：0-255）
- 需要时对属性添加引号
- 支持点符号分组（group.key=value）
- ReplaceAttr 回调用于属性转换

**HandlerOptions：**
- `Prefix string`：处理器级别前缀
- `Level *LevelVar`：最小级别（线程安全）
- `Output *OutputVar`：输出目标（线程安全）
- `ReplaceAttr func([]string, Attr) Attr`：转换属性
- `TimeFormat string`：时间格式字符串
- `NoColor bool`：禁用 ANSI 颜色

**颜色常量：**
- 标准 ANSI 颜色（0-7）：黑、红、绿、黄、蓝、品红、青、白
- 亮 ANSI 颜色（8-15）：亮色变体
- 216 色（16-231）：6×6×6 RGB 立方体
- 灰度（232-255）：24 级灰阶
- 内置颜色：reset、bright、faint、gray、white 和各种语义颜色

**颜色函数：**
- `ColorAttr(color uint8, attr Attr) Attr`：用颜色包装属性
- `Err(err error) Attr`：返回键为 "error" 的红色错误属性

#### 4. Record（记录，record.go）
日志事件的内部表示。

**结构：**
- `Time time.Time`：日志发生时间
- `Level Level`：日志级别
- `Message string`：日志消息
- `Prefix string`：可选前缀
- `front [nAttrsInline]Attr`：前 5 个属性的内联存储
- `nFront int`：front 中的属性数量
- `back []Attr`：额外属性的溢出存储

**关键方法：**
- `NewRecord(time, level, msg) Record`：创建新记录
- `AddAttrs(...Attr)`：添加属性（先内联后溢出）
- `Add(key, value)`：添加键值对
- `NumAttrs() int`：计算总属性数
- `Attrs(func(Attr) bool)`：遍历所有属性
- `Clone() Record`：深拷贝以安全修改

**性能优化：**
- 前 5 个属性使用内联数组（无分配）
- 仅在超过 5 个属性时分配切片
- 使用估计容量预分配

#### 5. Attr（属性，attr.go）
结构化日志属性（slog.Attr 的类型别名）。

**类型构造函数：**
- `String[T ~string](key, value) Attr`：带泛型约束的字符串值
- `Int[T ~int|~int8|~int16|~int32|~int64](key, value) Attr`：整数类型
- `Int64(key, value) Attr`：直接 int64
- `Uint[T ~uint|~uint8|~uint16|~uint32|~uint64](key, value) Attr`：无符号整数
- `Float[T ~float32|~float64](key, value) Attr`：浮点数
- `Bool[T ~bool](key, value) Attr`：布尔值
- `Time(key, time.Time) Attr`：时间戳
- `Duration(key, time.Duration) Attr`：时间间隔
- `Any(key, any) Attr`：任意值类型
- `Group(key, ...any) Attr`：嵌套属性组

**颜色支持：**
- `ColorAttr(color uint8, attr Attr) Attr`：对属性应用颜色
- `Err(err error) Attr`：红色错误属性的简写（颜色 9）
- `colorValue`：实现 slog.LogValuer 的内部包装器

**辅助函数：**
- `argsToAttrSlice([]any) []Attr`：将混合参数转换为属性
- `splitAttrs([]any) ([]Attr, []any)`：将 Attrs 与其他值分离
- 由 Logf 方法使用以支持混合结构化和 printf 参数

#### 6. Utilities（工具，util.go）
共享工具类型和函数。

**OutputVar：**
- 使用 atomic.Value 的线程安全可变 io.Writer
- `NewOutputVar(io.Writer) *OutputVar`：创建包装器
- `Set(io.Writer)`：原子更新输出
- `Output() io.Writer`：读取当前输出
- `Write([]byte) (int, error)`：实现 io.Writer
- `Discard() bool`：检查输出是否为 io.Discard

**缓冲池：**
- `buffer`：[]byte 的类型别名
- `newBuffer() *buffer`：从 sync.Pool 获取缓冲区
- `buffer.Free()`：将缓冲区返回到池（如果不太大）
- `buffer.WriteByte(byte)`：追加单个字节
- `buffer.WriteString(string)`：追加字符串
- 大小限制：16KB（更大的缓冲区不入池）

**Record 辅助函数：**
- `argsToAttr([]any) (Attr, []any)`：提取一个属性
- `countAttrs([]any) int`：计算参数中的属性数
- `countEmptyGroups([]any) int`：计算空组数
- `isEmptyAttr(Attr) bool`：检查属性是否为空
- `isEmptyGroup(Attr) bool`：检查组是否为空

#### 7. Package Functions（包级函数，l4g.go）
全局日志器和便利函数。

**全局状态：**
- `std *Logger`：默认包级日志器
- `channels sync.Map`：命名日志器缓存
- `OsExiter func(int)`：可替换的退出函数（用于测试）
- `NewFunc func(string) *Logger`：通道日志器的工厂

**包级函数：**
- `Default() *Logger`：获取默认日志器
- `SetDefault(*Logger)`：设置默认日志器
- `Channel(name string) *Logger`：获取/创建命名日志器（缓存）
- `SetLevel(Level)`：设置默认日志器级别
- `GetLevel() Level`：获取默认日志器级别
- `SetOutput(io.Writer)`：设置默认日志器输出
- `Output() io.Writer`：获取默认日志器输出
- 所有日志方法委托给默认日志器

**便利函数：**
- `WithAttrs(...any) *Logger`：创建带属性的派生日志器
- `WithPrefix(string) *Logger`：创建带前缀的派生日志器
- `WithGroup(string) *Logger`：创建带分组的派生日志器
- `FallbackErrorf(format, ...any)`：最后手段的错误日志到 stderr

## 文件结构

```
l4g/
├── l4g.go           # 包级 API 和全局日志器
├── logger.go        # Logger 类型和方法
├── level.go         # 日志级别定义和 LevelVar
├── handler.go       # Handler 接口和 SimpleHandler
├── record.go        # 日志事件的 Record 类型
├── attr.go          # 属性构造函数和辅助函数
├── util.go          # 共享工具（缓冲池等）
├── *_test.go        # 综合测试套件
├── README.md        # 用户文档（英文）
├── README.zh-CN.md  # 用户文档（中文）
├── LICENSE          # 许可证文件
├── go.mod           # Go 模块定义
├── llms.txt         # LLM 文档（英文）
└── llms-zh-CN.txt   # LLM 文档（中文，本文件）
```

## 使用模式

### 模式 1：简单的包级日志
```go
import "go-slim.dev/l4g"

// 直接使用包函数
l4g.Info("服务器启动")
l4g.Errorf("连接失败：%v", err)
```

### 模式 2：自定义日志器实例
```go
logger := l4g.New(l4g.Options{
    Output: os.Stdout,
    Level:  l4g.LevelDebug,
    NoColor: false,
})

logger.Debug("调试信息", l4g.String("component", "auth"))
```

### 模式 3：命名通道
```go
// 不同组件获得自己的缓存日志器
dbLog := l4g.Channel("database")
apiLog := l4g.Channel("api")

dbLog.Info("查询执行", l4g.Duration("time", 50*time.Millisecond))
apiLog.Info("请求处理", l4g.Int("status", 200))
```

### 模式 4：带预设的派生日志器
```go
// 基础日志器
base := l4g.Default()

// 创建带预设属性的派生日志器
reqLog := base.WithAttrs(
    l4g.String("request_id", "abc123"),
    l4g.String("user", "alice"),
)

// 所有后续日志包含预设属性
reqLog.Info("处理请求")      // 包含 request_id 和 user
reqLog.Error("请求失败")     // 包含 request_id 和 user
```

### 模式 5：分组属性
```go
logger := l4g.Default().WithGroup("http")

// 所有属性嵌套在 "http" 组下
logger.Info("请求",
    l4g.String("method", "GET"),    // 输出：http.method=GET
    l4g.Int("status", 200),         // 输出：http.status=200
)
```

### 模式 6：动态级别更改
```go
// 生产环境：仅警告和错误
l4g.SetLevel(l4g.LevelWarn)

// 调试模式：详细日志
if debugMode {
    l4g.SetLevel(l4g.LevelTrace)
}
```

### 模式 7：带 ReplaceAttr 的自定义处理器
```go
handler := l4g.NewSimpleHandler(l4g.HandlerOptions{
    Output: os.Stdout,
    Level:  l4g.NewLevelVar(l4g.LevelInfo),
    ReplaceAttr: func(groups []string, attr l4g.Attr) l4g.Attr {
        // 脱敏处理敏感数据
        if attr.Key == "password" || attr.Key == "token" {
            return l4g.String(attr.Key, "***REDACTED***")
        }
        // 为嵌套组添加前缀
        if len(groups) > 0 {
            attr.Key = strings.Join(groups, ".") + "." + attr.Key
        }
        return attr
    },
})

logger := l4g.New(l4g.Options{Handler: handler})
```

### 模式 8：混合结构化和 Printf 日志
```go
// Logf 方法同时支持 printf 参数和结构化属性
l4g.Infof("用户 %s 从 %s 登录",
    username, ipAddress,
    l4g.String("session", sessionID),  // 结构化属性
    l4g.Duration("duration", elapsed), // 另一个结构化属性
)
```

### 模式 9：带颜色的错误日志
```go
if err != nil {
    l4g.Error("操作失败",
        l4g.Err(err),  // 红色错误属性
        l4g.String("operation", "database_query"),
    )
}
```

### 模式 10：带自定义退出的测试
```go
func TestFatalLogging(t *testing.T) {
    // 替换 os.Exit 以便测试
    oldExiter := l4g.OsExiter
    exitCode := -1
    l4g.OsExiter = func(code int) { exitCode = code }
    defer func() { l4g.OsExiter = oldExiter }()

    l4g.Fatal("关键错误")

    if exitCode != 1 {
        t.Errorf("期望退出码 1，得到 %d", exitCode)
    }
}
```

## 最佳实践

1. **使用适当的日志级别**
   - Trace：极详细的流程跟踪
   - Debug：开发诊断
   - Info：正常操作（默认）
   - Warn：功能降级
   - Error：不会停止程序的失败
   - Panic：需要恢复的严重错误
   - Fatal：不可恢复的错误

2. **利用零分配**
   - 在生产环境设置适当的日志级别
   - 禁用的日志零开销
   - 对昂贵的计算使用 `logger.Enabled(level)`

3. **使用结构化日志**
   - 优先使用 `l4g.String("key", value)` 而非字符串格式化
   - 使用适当的类型构造函数（Int、Duration 等）
   - 避免在消息字符串中放入结构化数据

4. **通道命名约定**
   - 使用一致的分层名称："api.auth"、"db.postgres"
   - 通道被缓存，所以 Channel("name") 总是返回同一实例
   - 考虑使用包名或组件名

5. **线程安全**
   - 所有日志器方法都是线程安全的
   - SetLevel/SetOutput 是原子的，可安全并发调用
   - 处理器必须是线程安全的

6. **性能考虑**
   - 重用日志器（它们可安全并发使用）
   - 对常见属性使用 WithAttrs 而不是重复
   - 缓冲区自动池化
   - 除非必要，避免使用 fmt.Sprintf

7. **测试**
   - 测试输出使用 bytes.Buffer 或 io.Discard
   - 替换 OsExiter 以测试 Fatal 日志
   - 使用 NoColor: true 获得可预测的测试输出

8. **颜色使用**
   - 文件输出禁用颜色（NoColor: true）
   - 使用语义颜色：成功用绿色，错误用红色
   - ColorAttr 使用 8 位 ANSI（0-255 范围）
   - Err() 函数使用颜色 9（亮红色）

## API 快速参考

### Logger 方法
- `Log(level Leveler, msg string, args ...any)`
- `Logf(level Level, format string, args ...any)`
- `Logj(level Level, j map[string]any)`
- `Trace/Debug/Info/Warn/Error/Panic/Fatal(msg string, args ...any)`
- `Tracef/Debugf/Infof/Warnf/Errorf/Panicf/Fatalf(format string, args ...any)`
- `Tracej/Debugj/Infoj/Warnj/Errorj/Panicj/Fatalj(j map[string]any)`
- `WithAttrs(args ...any) *Logger`
- `WithPrefix(prefix string) *Logger`
- `WithGroup(name string) *Logger`
- `SetLevel(level Level)`
- `Level() Level`
- `SetOutput(w io.Writer)`
- `Output() io.Writer`
- `Enabled(level Level) bool`

### 属性构造函数
- `String[T ~string](key string, value T) Attr`
- `Int[T ~int|~int8|~int16|~int32|~int64](key string, value T) Attr`
- `Int64(key string, value int64) Attr`
- `Uint[T ~uint|~uint8|~uint16|~uint32|~uint64](key string, value T) Attr`
- `Float[T ~float32|~float64](key string, value T) Attr`
- `Bool[T ~bool](key string, value T) Attr`
- `Time(key string, v time.Time) Attr`
- `Duration(key string, value time.Duration) Attr`
- `Any(key string, value any) Attr`
- `Group(key string, args ...any) Attr`
- `ColorAttr(color uint8, attr Attr) Attr`
- `Err(err error) Attr`

### 包函数
- `New(opts Options) *Logger`
- `Default() *Logger`
- `SetDefault(l *Logger)`
- `Channel(name string) *Logger`
- `SetLevel(level Level)`
- `GetLevel() Level`
- `SetOutput(w io.Writer)`
- `Output() io.Writer`
- `WithAttrs(args ...any) *Logger`
- `WithPrefix(prefix string) *Logger`
- `WithGroup(name string) *Logger`

### 处理器创建
- `NewSimpleHandler(opts HandlerOptions) Handler`
- `NewLevelVar(level Level) *LevelVar`
- `NewOutputVar(w io.Writer) *OutputVar`

## 测试

库包含综合测试：
- 所有组件的单元测试（目标 100% 覆盖率）
- 线程安全的并发测试
- 性能验证的基准测试
- 端到端场景的集成测试

运行测试：
```bash
go test -v                    # 所有测试
go test -race                 # 带竞态检测
go test -bench=. -benchmem   # 基准测试
go test -cover               # 覆盖率报告
```

## 版本要求

- Go 1.24.0 或更高版本（使用泛型类型约束）
- 除标准库外无外部依赖

## 实现注意事项

1. **属性存储**：Record 使用内联数组存储前 5 个属性（常见情况的优化）
2. **级别值**：从 1 开始（不是 0）以区分零值
3. **缓冲池**：池化缓冲区的大小限制为 16KB
4. **通道缓存**：使用 sync.Map 实现线程安全的日志器缓存
5. **原子操作**：LevelVar 和 OutputVar 使用原子操作实现无锁读取
6. **颜色格式**：使用 ANSI 8 位颜色代码（0-255 范围）
7. **默认值**：Info 级别、os.Stderr 输出、time.StampMilli 格式

## 常见问题和解决方案

1. **文件输出中的颜色**：在 HandlerOptions 中设置 `NoColor: true`
2. **过多的调试输出**：使用 `SetLevel(LevelInfo)` 或更高级别
3. **测试 Fatal 日志**：用测试函数替换 `OsExiter`
4. **自定义格式化**：实现自定义 Handler 或使用 ReplaceAttr
5. **缺失日志**：使用 `Enabled(level)` 检查日志级别
6. **性能**：确保禁用的级别真正被禁用（它们应该零成本）

## 模块信息

- 模块：`go-slim.dev/l4g`
- 导入：`import "go-slim.dev/l4g"`
- 许可证：见 LICENSE 文件
- 仓库：go-slim 项目的一部分